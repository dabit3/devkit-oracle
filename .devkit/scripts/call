#!/usr/bin/env bash
set -e

# source in helper functions
source "$( dirname "${BASH_SOURCE[0]}" )/helpers/helpers.sh"


# Check if context parameter is provided
if [ -z "$1" ]; then
    log "Error: Missing context parameter"
    log "Usage: ./call '{\"version\":\"0.0.1\",\"context\":{...}}' '{\"signature\":\"(uint256,string,...)\",\"args\":\"(5,\"hello\",...)\"}'"
    exit 1
fi

# Check if params parameter is provided
if [ -z "$2" ]; then
    log "Error: Missing params parameter"
    log "Usage: ./call '{\"version\":\"0.0.1\",\"context\":{...}}' '{\"signature\":\"(uint256,string,...)\",\"args\":\"(5,\"hello\",...)\"}'"
    exit 1
fi

# Parse the JSON context and params
CONTEXT="$1"
PARAMS="$2"

# Check for required tools
ensureJq
ensureYq


if ! command -v cast &> /dev/null; then
    log "Error: cast not found. Please run 'avs create' first."
    exit 1
fi

# Extract signature and args from params JSON
SIGNATURE=$(echo "$PARAMS" | jq -r '.signature')
ARGS=$(echo "$PARAMS" | jq -r '.args')

# Validate signature and args
if [ "$SIGNATURE" == "null" ] || [ -z "$SIGNATURE" ]; then
    log "Error: Missing signature in params"
    log "Params must be in the format: '{\"signature\":\"(uint256,string)\",\"args\":\"(5,\"hello\")\"}'"
    exit 1
fi

if [ "$ARGS" == "null" ] || [ -z "$ARGS" ]; then
    log "Error: Missing args in params"
    log "Params must be in the format: '{\"signature\":\"(uint256,string)\",\"args\":\"(5,\"hello\")\"}'"
    exit 1
fi

# Format the signature to f(<signature>)
FORMATTED_SIGNATURE="f($SIGNATURE)"

# Generate the payload using cast abi-encode
set +e
PAYLOAD=$(cast abi-encode "$FORMATTED_SIGNATURE" "$ARGS" 2> >(tee >&2))
CAST_EXIT_CODE=$?
set -e

if [ $CAST_EXIT_CODE -ne 0 ]; then
    log ""
    log "Error: Failed to encode arguments using cast abi-encode"
    log "Signature: $SIGNATURE"
    log "Arguments: $ARGS"
    exit 1
fi

# Extract required values from context
ENVIRONMENT=$(echo "$CONTEXT" | jq -r '.context.name')
L2_RPC_URL=$(echo "$CONTEXT" | jq -r '.context.chains.l2.rpc_url')
PRIVATE_KEY_APP=$(echo "$CONTEXT" | jq -r '.context.app_private_key')
AVS_ADDRESS=$(echo "$CONTEXT" | jq -r '.context.avs.address')
TASK_MAILBOX_ADDRESS=$(echo "$CONTEXT" | jq -r '.context.eigenlayer.l2.task_mailbox')

# Get executor operator set ID from environment YAML file
ENVIRONMENT_YAML_FILE=".hourglass/context/${ENVIRONMENT}.yaml"
if [ ! -f "$ENVIRONMENT_YAML_FILE" ]; then
    log "Error: AVS environment file ${ENVIRONMENT_YAML_FILE} does not exist"
    exit 1
fi

EXECUTOR_OPERATOR_SET_ID=$(yq -r '.executor.operatorSetId' "$ENVIRONMENT_YAML_FILE")

# Validate required fields exist in JSON
if [ "$ENVIRONMENT" == "null" ] || [ -z "$ENVIRONMENT" ]; then
    log "Error: Missing name (environment) in context"
    exit 1
fi

if [ "$L2_RPC_URL" == "null" ] || [ -z "$L2_RPC_URL" ]; then
    log "Error: Missing L2_RPC_URL in context"
    exit 1
fi

if [ "$PRIVATE_KEY_APP" == "null" ] || [ -z "$PRIVATE_KEY_APP" ]; then
    log "Error: Missing app_private_key in context"
    exit 1
fi

if [ "$AVS_ADDRESS" == "null" ] || [ -z "$AVS_ADDRESS" ]; then
    log "Error: Missing avs.address in context"
    exit 1
fi

if [ "$EXECUTOR_OPERATOR_SET_ID" == "null" ] || [ -z "$EXECUTOR_OPERATOR_SET_ID" ]; then
    log "Error: Missing executor.operatorSetId in ${ENVIRONMENT_YAML_FILE}"
    exit 1
fi

# Validate Ethereum addresses
if [[ ! "$AVS_ADDRESS" =~ ^0x[a-fA-F0-9]{40}$ ]]; then
    log "Error: AVS_ADDRESS must be a valid Ethereum address (0x followed by 40 hex characters)"
    exit 1
fi

if [ "$TASK_MAILBOX_ADDRESS" == "null" ] || [ -z "$TASK_MAILBOX_ADDRESS" ]; then
  log "Error: Missing eigenlayer.l2.task_mailbox in context"
  exit 1
fi

if [[ ! "$TASK_MAILBOX_ADDRESS" =~ ^0x[a-fA-F0-9]{40}$ ]]; then
  log "Error: TASK_MAILBOX_ADDRESS must be a valid Ethereum address"
  exit 1
fi

# Validate payload is a hex string
if [[ ! "$PAYLOAD" =~ ^0x[a-fA-F0-9]+$ ]]; then
    log "Error: Generated payload must be a hex string (0x followed by hex characters)"
    log "Got: $PAYLOAD"
    exit 1
fi

log "Creating task on the TaskMailbox contract..."
log "Using payload encoded from signature: $SIGNATURE, args: $ARGS"

# Capture the last bytes32 printed by forge as the task hash
RAW_OUT_FILE="$(mktemp)"
# run your make target and tee its stdout so we can parse it
cd ./.devkit/contracts
PRIVATE_KEY_APP="${PRIVATE_KEY_APP}" make create-task \
  RPC_URL="${L2_RPC_URL}" ENVIRONMENT="${ENVIRONMENT}" TASK_MAILBOX_ADDRESS="${TASK_MAILBOX_ADDRESS}" \
  AVS_ADDRESS="${AVS_ADDRESS}" EXECUTOR_OPERATOR_SET_ID=${EXECUTOR_OPERATOR_SET_ID} \
  PAYLOAD="${PAYLOAD}" | tee "${RAW_OUT_FILE}"
cd - >/dev/null

# Capture taskHash from raw output
TASK_HASH=$(
  awk '/Created task with hash:/{getline; print;}' "${RAW_OUT_FILE}" \
  | grep -Eo '0x[a-fA-F0-9]{64}' | head -n1
)
if [[ ! "$TASK_HASH" =~ ^0x[a-fA-F0-9]{64}$ ]]; then
  log "Error: could not parse taskHash from create-task output"
  exit 1
fi
rm -f "${RAW_OUT_FILE}"

# Discovered taskHash, waiting for verification
log "Task created successfully:" 
log " - Task hash: ${TASK_HASH}"

# Poll for TaskVerified() logs
log "\nWaiting for TaskVerified()..."

# Start block just after creation to avoid missing the event
FROM_BLOCK_RAW="$(cast block-number --rpc-url "$L2_RPC_URL" | tr -d '[:space:]')"
FROM_BLOCK="$(printf '%s' "$FROM_BLOCK_RAW" | tr -cd '0-9')"
if [ -z "$FROM_BLOCK" ]; then
  log "Error: invalid from-block '$FROM_BLOCK_RAW'"; exit 1
fi

# 35s if sleep=5
MAX_ATTEMPTS=7
SLEEP=5
FOUND=0
EXECUTOR_SET_ID=""
EXECUTOR_CERT=""
RESULT_BYTES=""

# Poll for TaskVerified() logs
for ((i=1; i<=MAX_ATTEMPTS; i++)); do
  EVENT=$(cast logs \
    --rpc-url "$L2_RPC_URL" \
    --address "$TASK_MAILBOX_ADDRESS" \
    --from-block "$FROM_BLOCK" \
    --to-block latest \
    "TaskVerified(address,bytes32,address,uint32,bytes,bytes)" \
    "$TASK_HASH" --json)

  if [ -n "$EVENT" ] && [ "$EVENT" != "[]" ]; then
    # Pick the first matching log
    DATA="$(jq -r '.[-1].data' <<<"$EVENT")"
    TOPIC1=$(jq -r '.[-1].topics[1]' <<<"$EVENT")   # aggregator
    TOPIC2=$(jq -r '.[-1].topics[2]' <<<"$EVENT")   # taskHash
    TOPIC3=$(jq -r '.[-1].topics[3]' <<<"$EVENT")   # avs

    # Indexed params from topics
    AGGREGATOR="0x${TOPIC1:26}"
    TASK_HASH="$TOPIC2"
    AVS="0x${TOPIC3:26}"

    # Remaining params from decoded data
    DECODED="$(cast calldata-decode "f(uint32,bytes,bytes)" "0x00000000${DATA#0x}")"
    EXECUTOR_SET_ID="$(printf '%s\n' "$DECODED" | sed -n '1p')"
    EXECUTOR_CERT="$(printf '%s\n' "$DECODED" | sed -n '2p')"
    RESULT_BYTES="$(printf '%s\n' "$DECODED" | sed -n '3p')"
      
    # Print to stderr
    log "\nTaskVerified event received:"
    log " - Aggregator: $AGGREGATOR"
    log " - TaskHash: $TASK_HASH"
    log " - AVS: $AVS"
    log " - ExecutorOperatorSetId: $EXECUTOR_SET_ID"
    log " - ExecutorCert: $EXECUTOR_CERT"
    log " - TaskResult: $RESULT_BYTES\n"

    FOUND=1
    break
  fi
  sleep $SLEEP
done

# Failed to find TaskVerified event, fail gracefully
if [ $FOUND -eq 0 ]; then
  log " - Timeout: TaskVerified() not seen\n"
  jq -nc --arg taskHash "$TASK_HASH" '{"taskHash":$taskHash,"status":"timeout"}' | jq -c .
  exit 1
fi

# Print the combined JSON result - this is the ONLY stdout output
jq -nc \
  --arg taskHash "$TASK_HASH" \
  --arg executorOperatorSetId "$EXECUTOR_SET_ID" \
  --arg executorCert "$EXECUTOR_CERT" \
  --arg result "$RESULT_BYTES" \
  '{"taskHash":$taskHash,"status":"verified","executorOperatorSetId":$executorOperatorSetId,"executorCert":$executorCert,"result":$result}' | jq -c .
